//
//  unit.h
//  pcc01
//
//  Created by Riya.Liel on 2015/01/19.
//
//

#ifndef __pcc01__unit__
#define __pcc01__unit__

#include "cocos2d.h"
#include "weapon.h"

class object{
protected:
    cocos2d::Sprite* unitImage;
    cocos2d::Size size;
    
    void moveTarget(int); //move by the animation, argument is amount of movement
public:
    object(std::string _filename);
    virtual bool isCollision(object* target)=0; // check a collision with the target
    virtual void progress()=0; //progress frame and act
    //void setImage(cocos2d::Sprite*);
    cocos2d::Sprite* getImage(){return unitImage;}
};

class player : public object{
public:
    player(std::string _filename) :object(_filename){myWeapon = blade::getInstance();}
    object* attack(); //make the effect object
    
    //It is not necessary to use
    bool isCollision(object* target)override{return true;}
    void progress()override{};
private:
    weapon* myWeapon;
};

class enemy : public object{
public:
    enemy(std::string _filename) :object(_filename){}
    
    void setMovement(int _move){movement = _move;}
    int getMovement(){return movement;}
    
    void progress() override;
    bool isCollision(object* obj) override{return true;} //todo
private:
    int movement; //Amount of movement
};

//this class is generated by player attack
class effect : public object{
public:
    effect(std::string _filename);
    
    void setReach(rangeType _type); //The reach of the attack
    void setMovement(int _move){movement = _move;}
    void setRemain(int _remain){remainFrame = _remain;} //will release the remaining time reaches 0
    
    int getMovement(){return movement;}
    
    bool isCollision(object* target) override; //If that's true , to attack the target
    void progress() override;
private:
    rangeType rtype; //Kind of attack range
    int movement;
    int remainFrame;
};

#endif /* defined(__pcc01__unit__) */
